Enduro/X Java Internal Developer Guide
======================================
Madars Vitolins
v1.0, 2018-08:
        Initial draft
:doctype: book

== Intro

This document is for internal purposes of the Enduro/X Java module developer.
It contains solutions for main pitfalls found during the development process.
Also document contains main configuration steps to get the development IDE
working.

== NetBeans configuration

For Enduro/X and other related modules, NetBeans is preferred IDE for development.
As module is programmed in Java and C languages, two projects in NetBeans are
required. As NetBeans does not allow to project to co-exist in the same folder,
some play with symbolic links into separate folder are required. This document
will guide you for setting up the environment for developing Enduro/X for Java.

=== Packages for Java

This document assumes that NetBeans for C/C++ are installed. Thus to get
Java projects working, following additional plugins must be installed. As
plugins require JDK to be present for NetBeans, the IDE must be started with
'--jdkhome' attribute. In particular case NetBeans 8.2 was installed on Linux Mint
Mate 19 as a root. For this document we will use "java-8-openjdk-amd64".

--------------------------------------------------------------------------------

$  /usr/local/netbeans-8.2/bin/netbeans --jdkhome /usr/lib/jvm/java-8-openjdk-amd64

--------------------------------------------------------------------------------

Once NetBeans are started, go to: *Tools > Plugins > Available Plugins* and select
following ones for install:

image:images/netbeans_java_install.png[caption="Figure 1: ", title="NetBeans Java Plugin Install"]

Once modules are installed, it is recommended to update the NetBeans launcher 
shortcut, because the jdkhome argument is mandatory in order to use java projects

image:images/update_shortcut.png[caption="Figure 2: ", title="NetBeans Shortcut update"]

== Checking out Enduro/X Java project

With this step we will prepare two folders for the project. The first one is
default project folder "endurox-java" checked out from source repository. The
second one (which will be actually used by Java part for NetBeans) is created.
And symbolic links are added

--------------------------------------------------------------------------------

$ git clone https://github.com/endurox-dev/endurox-java
$ mkdir endurox-j
$ cd endurox-j
$ ln -s ../endurox-java/build.xml .
$ ln -s ../endurox-java/tests .
$ ln -s ../endurox-java/libsrc .

--------------------------------------------------------------------------------

== Opening projects in NetBeans

The main project is "endurox-java" which is processed by CMake. The CMake build
performs building of all parts Java and C. But for IDE we open this project for
as the C project.

=== Opening C project in NetBeans
Before opening the project in NetBeans, the cmake shall be run from shell, so
that it performs initial configuration, as with NetBeans the configuration
is little bit different:

--------------------------------------------------------------------------------

$ cd endurox-java
$ cmake .

--------------------------------------------------------------------------------

After this step is done, start the NetBeans, and create new project with existing
source code:

image:images/new_c_project.png[caption="Figure 3: ", title="New C Project"]

And then select the folder which checked out sources:

image:images/select_c_sources.png[caption="Figure 4: ", title="Select sources"]

=== Opening Java project in NetBeans

The Java project shall be based on folder where symlinks are produced. That is
"endurox-j" folder. The project type is "Standard" Java free-form project. The
project contains an Ant script which is not normally used for build purposes, but
that is used for NetBeans (or Eclipse) to parse the project structure (CMake
is not supported yet for Java projects). Also during the development the
ant script (endurox-java/build.xml) must be maintained.

Create a new project:

image:images/new_java_project.png[caption="Figure 5: ", title="New Java Project"]


Select project folder:

image:images/select_java_folder.png[caption="Figure 5: ", title="Select Java folder"]

Ant commands:

image:images/ant_commands.png[caption="Figure 6: ", title="Ant commands"]

Ant next screen is significant one, as here all Java directories must be manually
added, as the libsrc only is added by default. All unit tests which will be
changed/added during the development must be added here:

image:images/java_sources.png[caption="Figure 7: ", title="Java sources"]

Once project is created, this list can be altered in 
*project properties > Java Sources*

Also the class path shall include the Junit JARS. The next screen shows how
to do it when project is configured, but that can be done during the initial
wizard too.

The class path attributes:

image:images/java_classpath.png[caption="Figure 8: ", title="Java class path"]



== Distributed transaction processing architecture

The nice thing about Java is that their JDBC drivers, are that they provide
two phase commit interfaces. The basic principle for the operations are the
same which are used by X/Open XA interface. See 
https://docs.oracle.com/javaee/5/api/javax/transaction/xa/XAResource.html.

Enduro/X by it self uses following architecture for the XA two phase transactions:

1. There is driver library needed (as a frontend) for XATMI sub-system to
acquire a XA Resource Manager (RM) switch (structure with callbacks defined
inside). The driver usually is provided by Enduro/X. The driver is configured
in the *NDRX_XA_DRIVERLIB* environment/global variable.

2. The second shared library is back-end or resource manager by it self, this
also implements XA switch functions. This goes into *NDRX_XA_RMLIB* environment
variable.

With respect to Java module, the developer would expect that JDBC transactions
firstly would be managed by Enduro/X ATMI Context, as it provides tpbegin(),
tpcommit(), etc. methods. This would mean, that if developer opens the database
connection and would expect to start working with DB, some handler needs to
registered with given ATMI context, so that XATMI sub-system could manage the
state of the given connection.

Also here raises the question, how long the object is able to work with given
DB connection? Is the session open or not? As the transaction is not associated
with the thread as in X/Open standard, but it is being associated with the 
connection object. Thus according the Oracle examples:
https://docs.oracle.com/cd/B19306_01/java.102/b14355/xadistra.htm#i1066952
once begin is issued, the connection is able to work with the database, by using
connection object:

--------------------------------------------------------------------------------
OracleXADataSource oxds1 = new OracleXADataSource();
XAConnection pc1  = oxds1.getXAConnection();
Connection conn1 = pc1.getConnection();
...
oxar1.start (xid1, XAResource.TMNOFLAGS);
>> DO JDBC WORK <<<
oxar1.end(xid1, XAResource.TMSUCCESS);
conn1.close();
pc1.close();
--------------------------------------------------------------------------------

The start/end/close etc shall be handled by RM shared library. Also the commit
actually shall be done by transaction manager (TMSRV) process and not by the
java client it self.

Thus we need following libs:

a) libndrxxajavX.so, where X is "s" - static reg, or "d" - dynamic registration.
Library is configured for java based applications. This is configured into
*NDRX_XA_DRIVERLIB*.

b) libexjdbcxa.so, JDBC XA interface which would perform the JNI calls. This
would be configured into *NDRX_XA_RMLIB*. And would go for java app and *tmsrv*.

c) As *tmsrv* does not know anything about java, we need a different 
*NDRX_XA_DRIVERLIB* here, as it needs to start embedded java process and
should configure the environment for the "libexjdbcxa.so".

As from JNI side to work probably with java env following data is required:

- ptr to JNIEnv 

- ptr to XAConnection as from this we want to manage the transaction.


Thus we need to store somewhere when running at C side all the above data.
Question is only where, because our calls can be done in two ways:

1. Directly from Java in case of normal java Ops

2. Directly from C, when TMSRV will be running. Here question, is about shared
java env and ATMI context.

To solve above problem, the requirement from "libexjdbcxa.so" would be that
current thread is associated with ATMI TLS data where the above pointers are
stored. It could be some kind of structure and ATMI tls specific pointer.

For "libexjdbcxa.so" we would like to avoid any jar dependencies, except
the actual JDBC driver. Thus one way would be to compile these resources
in similar way as done with "exjld" binary linker.


:numbered!:

[bibliography]
Additional documentation 
------------------------
This section lists additional related documents.

[bibliography]
.Internet resources
- [[[ATMI-API]]] http://docs.oracle.com/cd/E13203_01/tuxedo/tux71/html/pgint6.htm
- [[[FML-API]]] http://docs.oracle.com/cd/E13203_01/tuxedo/tux91/fml/index.htm

[glossary]
Glossary
--------
This section lists

[glossary]
ATMI::
  Application Transaction Monitor Interface

UBF::
  Unified Buffer Format it is similar API as Tuxedo's FML


////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
